<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Momentum Runner - Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .game-container {
            position: relative;
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
            backdrop-filter: blur(10px);
        }

        h1 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 800;
        }

        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        #gameCanvas {
            border: 4px solid #667eea;
            border-radius: 15px;
            background: linear-gradient(180deg, #90caf9 0%, #e3f2fd 40%, #c8e6c9 40%, #a5d6a7 100%);
            cursor: crosshair;
            max-width: 100%;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.2);
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            gap: 20px;
        }

        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border-radius: 15px;
            flex: 1;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
            transition: transform 0.2s;
        }

        .stat-box:hover {
            transform: translateY(-3px);
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 2.2em;
            font-weight: bold;
            margin-top: 5px;
        }

        .controls {
            margin-top: 20px;
            color: #666;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .controls strong {
            color: #667eea;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px 50px;
            border-radius: 25px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
            display: none;
            z-index: 10;
            min-width: 350px;
        }

        .game-over.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translate(-50%, -60%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        .game-over h2 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .restart-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 45px;
            border-radius: 30px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .restart-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        .restart-btn:active {
            transform: translateY(-1px);
        }

        .links {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #e0e7ff;
        }

        .links a {
            color: #667eea;
            text-decoration: none;
            margin: 0 15px;
            font-weight: 600;
            transition: color 0.3s;
        }

        .links a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .social-links {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e0e7ff;
        }

        .social-links a {
            display: inline-block;
            margin: 0 12px;
            padding: 8px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
        }

        .social-links a:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .speed-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>‚ö° Momentum Runner</h1>
        <p class="subtitle">Mario‚Äëstyle platformer: run, jump, collect!</p>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="scoreDisplay">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Best</div>
                <div class="stat-value" id="highScoreDisplay">0</div>
            </div>
        </div>

        <button id="startBtn" class="restart-btn" style="margin: 20px 0;">Start Game</button>

        <canvas id="gameCanvas" width="800" height="450"></canvas>

        <div class="controls">
            <strong>Controls:</strong> A/D or ‚Üê ‚Üí to move | <strong>SPACE</strong> to jump<br>
            üí® Build momentum, üí∞ collect coins, ‚ùå avoid enemies & pits!
        </div>

        <div class="links">
            <a href="scratch.html">‚Üê Back to Projects</a>
            <a href="index.html">Home</a>
        </div>

        <div class="social-links">
            <a href="https://www.linkedin.com/in/harrison-beck04" target="_blank">LinkedIn</a>
            <a href="https://www.instagram.com/harrydbeck/" target="_blank">Instagram</a>
        </div>

        <div class="speed-indicator" id="speedIndicator">Speed: 0</div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>Game Over!</h2>
        <p style="font-size: 1.3em; margin: 20px 0; color: #666;">
            Final Score: <strong id="finalScore" style="color: #667eea; font-size: 1.4em;">0</strong>
        </p>
        <button class="restart-btn" onclick="restartGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI state
        const scoreDisplay = document.getElementById('scoreDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const speedIndicator = document.getElementById('speedIndicator');
        const gameOverPanel = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const startBtn = document.getElementById('startBtn');

        let score = 0;
        let highScore = Number(localStorage.getItem('momentumRunnerHS') || 0);
        highScoreDisplay.textContent = highScore;

        let gameRunning = false;
        let gameOverFlag = false;

        // Physics constants
        const GRAVITY = 0.7;
        const MOVE_ACCEL = 0.6;
        const MAX_RUN_SPEED = 6;
        const FRICTION_GROUND = 0.80;
        const FRICTION_AIR = 0.95;
        const JUMP_VELOCITY = -13;
        const TERMINAL_VELOCITY = 20;

        // Camera
        const camera = {
            x: 0,
            y: 0
        };

        // World
        const world = {
            width: 4000,
            height: canvas.height
        };

        // Player
        const player = {
            x: 150,
            y: 0,
            width: 32,
            height: 40,
            vx: 0,
            vy: 0,
            onGround: false,
            facing: 1, // 1 right, -1 left
            color: '#764ba2'
        };

        // Entities
        let platforms = [];
        let coins = [];
        let enemies = [];
        let particles = [];

        // Controls
        const keys = {};
        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.code === 'ArrowLeft') keys['arrowleft'] = true;
            if (e.code === 'ArrowRight') keys['arrowright'] = true;
            if (e.code === 'Space') keys[' '] = true;

            if ((e.code === 'Space' || e.code === 'ArrowUp') && player.onGround && gameRunning && !gameOverFlag) {
                e.preventDefault();
                playerJump();
            }
        });

        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            if (e.code === 'ArrowLeft') keys['arrowleft'] = false;
            if (e.code === 'ArrowRight') keys['arrowright'] = false;
            if (e.code === 'Space') keys[' '] = false;
        });

        startBtn.addEventListener('click', () => {
            if (!gameRunning) {
                startGame();
            }
        });

        function startGame() {
            resetWorld();
            gameRunning = true;
            gameOverFlag = false;
            startBtn.style.display = 'none';
            gameOverPanel.classList.remove('show');
        }

        function resetWorld() {
            score = 0;
            scoreDisplay.textContent = score;
            camera.x = 0;

            player.x = 150;
            player.y = 200;
            player.vx = 0;
            player.vy = 0;
            player.onGround = false;
            player.facing = 1;

            platforms = [];
            coins = [];
            enemies = [];
            particles = [];

            buildLevel();
        }

        // Simple rectangle collision test (AABB)
        function rectsOverlap(a, b) {
            return (
                a.x < b.x + b.width &&
                a.x + a.width > b.x &&
                a.y < b.y + b.height &&
                a.y + a.height > b.y
            );
        }

        function buildLevel() {
            const groundHeight = 60;
            // Main ground
            platforms.push({
                x: 0,
                y: world.height - groundHeight,
                width: world.width,
                height: groundHeight,
                color: '#4caf50'
            });

            // Floating platforms (Mario‚Äëlike progression)[web:21][web:28]
            const platformData = [
                { x: 300, y: 320 },
                { x: 500, y: 260 },
                { x: 750, y: 260 },
                { x: 1050, y: 300 },
                { x: 1300, y: 250 },
                { x: 1600, y: 230 },
                { x: 1900, y: 280 },
                { x: 2200, y: 240 },
                { x: 2500, y: 210 },
                { x: 2800, y: 260 },
                { x: 3100, y: 240 },
                { x: 3400, y: 220 }
            ];

            platformData.forEach(p => {
                platforms.push({
                    x: p.x,
                    y: p.y,
                    width: 140,
                    height: 20,
                    color: '#66bb6a'
                });
            });

            // Coins on or near platforms
            platformData.forEach(p => {
                coins.push({
                    x: p.x + 55,
                    y: p.y - 30,
                    width: 18,
                    height: 18,
                    collected: false
                });
            });

            // Ground coins
            for (let i = 350; i < world.width; i += 350) {
                coins.push({
                    x: i,
                    y: world.height - groundHeight - 40,
                    width: 18,
                    height: 18,
                    collected: false
                });
            }

            // Enemies patrolling some platforms[web:21][web:28]
            const enemyPlatforms = [platforms[2], platforms[4], platforms[6], platforms[8]];
            enemyPlatforms.forEach(plat => {
                enemies.push({
                    x: plat.x + 20,
                    y: plat.y - 24,
                    width: 28,
                    height: 24,
                    vx: 1.2,
                    patrolLeft: plat.x + 10,
                    patrolRight: plat.x + plat.width - 38,
                    alive: true
                });
            });
        }

        function playerJump() {
            player.vy = JUMP_VELOCITY;
            player.onGround = false;
            spawnJumpParticles();
        }

        function spawnJumpParticles() {
            const count = 10;
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height,
                    vx: (Math.random() - 0.5) * 3,
                    vy: -Math.random() * 3,
                    life: 20 + Math.random() * 10,
                    radius: 2 + Math.random() * 2,
                    color: '#667eea'
                });
            }
        }

        function spawnCoinParticles(cx, cy) {
            for (let i = 0; i < 12; i++) {
                particles.push({
                    x: cx,
                    y: cy,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 25 + Math.random() * 10,
                    radius: 2 + Math.random() * 2,
                    color: '#ffd700'
                });
            }
        }

        function spawnEnemyHitParticles(ex, ey) {
            for (let i = 0; i < 14; i++) {
                particles.push({
                    x: ex + 10,
                    y: ey + 10,
                    vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 4,
                    life: 25 + Math.random() * 10,
                    radius: 2 + Math.random() * 2,
                    color: '#ff5252'
                });
            }
        }

        function updatePlayer(dt) {
            let moveLeft = keys['a'] || keys['arrowleft'];
            let moveRight = keys['d'] || keys['arrowright'];

            if (moveLeft) {
                player.vx -= MOVE_ACCEL;
                player.facing = -1;
            }
            if (moveRight) {
                player.vx += MOVE_ACCEL;
                player.facing = 1;
            }

            if (!moveLeft && !moveRight && player.onGround) {
                player.vx *= FRICTION_GROUND;
            } else if (!player.onGround) {
                player.vx *= FRICTION_AIR;
            }

            if (player.vx > MAX_RUN_SPEED) player.vx = MAX_RUN_SPEED;
            if (player.vx < -MAX_RUN_SPEED) player.vx = -MAX_RUN_SPEED;

            player.vy += GRAVITY;
            if (player.vy > TERMINAL_VELOCITY) player.vy = TERMINAL_VELOCITY;

            // Horizontal move and collisions[web:21][web:39]
            player.x += player.vx;
            resolveCollisionsAxis('x');

            // Vertical move and collisions
            player.y += player.vy;
            player.onGround = false;
            resolveCollisionsAxis('y');

            // Check pits (fall off bottom)
            if (player.y > world.height + 200) {
                triggerGameOver();
            }

            // Clamp within world
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > world.width) {
                player.x = world.width - player.width;
            }

            const speedMag = Math.abs(player.vx).toFixed(1);
            speedIndicator.textContent = `Speed: ${speedMag}`;
        }

        function resolveCollisionsAxis(axis) {
            const playerBox = {
                x: player.x,
                y: player.y,
                width: player.width,
                height: player.height
            };

            for (let plat of platforms) {
                const platBox = {
                    x: plat.x,
                    y: plat.y,
                    width: plat.width,
                    height: plat.height
                };

                if (!rectsOverlap(playerBox, platBox)) continue;

                if (axis === 'x') {
                    if (player.vx > 0) {
                        player.x = plat.x - player.width;
                    } else if (player.vx < 0) {
                        player.x = plat.x + plat.width;
                    }
                    player.vx = 0;
                    playerBox.x = player.x;
                } else if (axis === 'y') {
                    if (player.vy > 0) {
                        player.y = plat.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                    } else if (player.vy < 0) {
                        player.y = plat.y + plat.height;
                        player.vy = 0;
                    }
                    playerBox.y = player.y;
                }
            }
        }

        function updateEnemies(dt) {
            enemies.forEach(enemy => {
                if (!enemy.alive) return;
                enemy.x += enemy.vx;

                if (enemy.x < enemy.patrolLeft) {
                    enemy.x = enemy.patrolLeft;
                    enemy.vx = Math.abs(enemy.vx);
                } else if (enemy.x + enemy.width > enemy.patrolRight) {
                    enemy.x = enemy.patrolRight - enemy.width;
                    enemy.vx = -Math.abs(enemy.vx);
                }

                const enemyBox = {
                    x: enemy.x,
                    y: enemy.y,
                    width: enemy.width,
                    height: enemy.height
                };
                const playerBox = {
                    x: player.x,
                    y: player.y,
                    width: player.width,
                    height: player.height
                };

                if (!rectsOverlap(playerBox, enemyBox)) return;

                const playerBottom = player.y + player.height;
                const enemyTop = enemy.y;

                if (playerBottom <= enemyTop + 10 && player.vy > 0) {
                    enemy.alive = false;
                    player.vy = JUMP_VELOCITY * 0.6;
                    score += 50;
                    scoreDisplay.textContent = score;
                    spawnEnemyHitParticles(enemy.x, enemy.y);
                } else {
                    triggerGameOver();
                }
            });
        }

        function updateCoins(dt) {
            coins.forEach(coin => {
                if (coin.collected) return;

                const coinBox = {
                    x: coin.x,
                    y: coin.y,
                    width: coin.width,
                    height: coin.height
                };
                const playerBox = {
                    x: player.x,
                    y: player.y,
                    width: player.width,
                    height: player.height
                };

                if (rectsOverlap(playerBox, coinBox)) {
                    coin.collected = true;
                    score += 10;
                    scoreDisplay.textContent = score;
                    spawnCoinParticles(coin.x + coin.width / 2, coin.y + coin.height / 2);
                }
            });
        }

        function updateParticles(dt) {
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.15;
                p.life -= 1;
            });
        }

        function updateCamera() {
            const target = player.x + player.width / 2;
            const center = canvas.width / 2;
            let desiredX = target - center;

            if (desiredX < 0) desiredX = 0;
            if (desiredX > world.width - canvas.width) {
                desiredX = world.width - canvas.width;
            }

            camera.x += (desiredX - camera.x) * 0.2;
            camera.y = 0;
        }

        function triggerGameOver() {
            if (gameOverFlag) return;
            gameOverFlag = true;
            gameRunning = false;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('momentumRunnerHS', highScore);
                highScoreDisplay.textContent = highScore;
            }

            finalScoreEl.textContent = score;
            gameOverPanel.classList.add('show');
            startBtn.style.display = 'inline-block';
            startBtn.textContent = 'Restart';
        }

        function restartGame() {
            startGame();
        }

        window.restartGame = restartGame;

        function drawBackground() {
            const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGrad.addColorStop(0, '#90caf9');
            skyGrad.addColorStop(0.4, '#e3f2fd');
            skyGrad.addColorStop(0.4, '#c8e6c9');
            skyGrad.addColorStop(1, '#a5d6a7');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            const clouds = [
                { x: 80, y: 60 },
                { x: 260, y: 90 },
                { x: 520, y: 50 },
                { x: 700, y: 110 }
            ];
            clouds.forEach(cloud => {
                const cx = cloud.x - (camera.x * 0.5) % (canvas.width + 200);
                ctx.beginPath();
                ctx.arc(cx, cloud.y, 25, 0, Math.PI * 2);
                ctx.arc(cx + 25, cloud.y + 8, 20, 0, Math.PI * 2);
                ctx.arc(cx - 25, cloud.y + 10, 20, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPlatforms() {
            platforms.forEach(plat => {
                const screenX = Math.floor(plat.x - camera.x);
                const screenY = Math.floor(plat.y - camera.y);
                if (screenX + plat.width < 0 || screenX > canvas.width) return;

                ctx.fillStyle = plat.color;
                ctx.fillRect(screenX, screenY, plat.width, plat.height);

                ctx.fillStyle = 'rgba(255,255,255,0.25)';
                ctx.fillRect(screenX, screenY, plat.width, 6);
            });
        }

        function drawCoins() {
            coins.forEach(coin => {
                if (coin.collected) return;
                const screenX = coin.x - camera.x + coin.width / 2;
                const screenY = coin.y - camera.y + coin.height / 2;

                if (screenX < -40 || screenX > canvas.width + 40) return;

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.ellipse(0, 0, 10, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff59d';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(0, 0, 4, 10, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                if (!enemy.alive) return;
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;
                if (screenX + enemy.width < 0 || screenX > canvas.width) return;

                ctx.fillStyle = '#ff5252';
                ctx.fillRect(screenX, screenY, enemy.width, enemy.height);

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(screenX + 4, screenY + 6, 8, 8);
                ctx.fillRect(screenX + enemy.width - 12, screenY + 6, 8, 8);
                ctx.fillStyle = '#000000';
                ctx.fillRect(screenX + 7, screenY + 9, 4, 4);
                ctx.fillRect(screenX + enemy.width - 9, screenY + 9, 4, 4);

                ctx.fillStyle = '#c62828';
                ctx.beginPath();
                ctx.moveTo(screenX, screenY + enemy.height);
                ctx.lineTo(screenX + enemy.width / 2, screenY + enemy.height - 8);
                ctx.lineTo(screenX + enemy.width, screenY + enemy.height);
                ctx.closePath();
                ctx.fill();
            });
        }

        function drawPlayer() {
            const screenX = player.x - camera.x;
            const screenY = player.y - camera.y;

            ctx.save();
            ctx.translate(screenX + player.width / 2, screenY + player.height / 2);
            ctx.scale(player.facing, 1);
            ctx.translate(-player.width / 2, -player.height / 2);

            ctx.fillStyle = player.color;
            ctx.fillRect(0, 0, player.width, player.height);

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(5, 8, 10, 10);
            ctx.fillRect(player.width - 15, 8, 10, 10);
            ctx.fillStyle = '#000000';
            ctx.fillRect(9, 12, 4, 4);
            ctx.fillRect(player.width - 11, 12, 4, 4);

            ctx.fillStyle = '#5e35b1';
            ctx.fillRect(4, 0, player.width - 8, 8);

            ctx.restore();
        }

        function drawParticles() {
            particles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                if (screenX < -20 || screenX > canvas.width + 20) return;

                ctx.globalAlpha = Math.max(0, p.life / 30);
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            const dt = (timestamp - lastTime) / 16.67;
            lastTime = timestamp;

            if (gameRunning) {
                updatePlayer(dt);
                updateEnemies(dt);
                updateCoins(dt);
                updateParticles(dt);
                updateCamera();
            }

            drawBackground();
            drawPlatforms();
            drawCoins();
            drawEnemies();
            drawPlayer();
            drawParticles();

            requestAnimationFrame(gameLoop);
        }

        resetWorld();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
